// The following directive is necessary to build the package:

//go:build ignore
// +build ignore

// This program generates stopwords.go. It can be invoked by running
//go:generate

//go:generate go run ../gen/stopwords.go

package main

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"os"
	"path"
	"text/template"
	"time"
)

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
// using data from
// {{ .JSON }}
package tokenizer
{{- range $funcName, $stopwords := .FILTER }}

//{{ $funcName }} returns true if word is stop word
func {{ $funcName }}(word string) bool {
	switch word {
		{{- range $idx, $item :=  $stopwords }}
		case "{{ $item }}":
			return true
		{{- end }}
		default:
			return false
	}
}
{{- end }}
`))

func main() {

	jsonPaths := []string{path.Join(
		"..", "gen", "stopwords_de.json",
	), path.Join(
		"..", "gen", "stopwords_en.json",
	)}

	stopWords := map[string][]string{
		"IsGermanStopWord":  {jsonPaths[0]},
		"IsEnglishStopWord": {jsonPaths[1]},
	}

	genPath := path.Join(
		"..", "tokenizer", "gen_stopwords.go",
	)

	if f, err := os.Create(genPath); err != nil {
		log.Fatal(err)
	} else {
		defer f.Close()
		for name, files := range stopWords {
			data := []string{}
			if file, err := ioutil.ReadFile(files[0]); err == nil {
				if err = json.Unmarshal([]byte(file), &data); err == nil {
					stopWords[name] = data
				} else {
					log.Fatal(err)
				}
			} else {
				log.Fatal(err)
			}
		}
		packageTemplate.Execute(f, struct {
			Timestamp time.Time
			JSON      []string
			FILTER    map[string][]string
		}{
			Timestamp: time.Now(),
			JSON:      jsonPaths,
			FILTER:    stopWords,
		})
	}

}
